//------------------------------------------------------------------------------
// VitisNet P4 component wrapper for integration with SmartNIC p4_app
//
// NOTE: This file is autogenerated. DO NOT EDIT.
//------------------------------------------------------------------------------

module {{ props.name }}_wrapper (
    // Clock/reset
    input logic           core_clk,
    input logic           core_rstn,

    // AXI-L
    axi4l_intf.peripheral axil_if,

    // AXI
    axi4s_intf.rx         axis_rx,
    axi4s_intf.tx         axis_tx,

    // Metadata
    input  logic          user_metadata_in_valid,
    input  logic [{{ props.user_metadata_wid - 1 }}:0]   user_metadata_in,
    output logic          user_metadata_out_valid,
    output logic [{{ props.user_metadata_wid - 1 }}:0]   user_metadata_out,

    // HBM AXI3
    axi3_intf.controller  axi_to_hbm [16]
);
    import sdnet_0_pkg::*;

    // --- sdnet_0 instance ---
    //   Generated using Xilinx VitisNet P4 from P4 file:
    //   {{ props.p4_file }}
    //
    //   Packet processing rate: {{ props.pkt_rate_mhz }} MHz

    {{ props.name }} i_{{ props.name }} (
        // Clocks & Resets
        .s_axis_aclk             (core_clk), // {{ props.axis_clk_freq_mhz }} MHz
        .s_axis_aresetn          (core_rstn),
        .s_axi_aclk              (axil_if.aclk),
        .s_axi_aresetn           (axil_if.aresetn),
        .cam_mem_aclk            (core_clk), // {{ props.cam_mem_clk_freq_mhz }} MHz
        .cam_mem_aresetn         (core_rstn),
        {%- if props.hbm_axi_if_num > 0 %}
        .m_axi_hbm_aclk          (core_clk),
        .m_axi_hbm_aresetn       (core_rstn),
        {% endif %}
        // Metadata
        .user_metadata_in        (user_metadata_in),         
        .user_metadata_in_valid  (user_metadata_in_valid),   
        .user_metadata_out       (user_metadata_out),
        .user_metadata_out_valid (user_metadata_out_valid),  
        
        // Slave AXI-lite interface
        .s_axi_awaddr            (axil_if.awaddr),
        .s_axi_awvalid           (axil_if.awvalid),
        .s_axi_awready           (axil_if.awready),
        .s_axi_wdata             (axil_if.wdata),
        .s_axi_wstrb             (axil_if.wstrb),
        .s_axi_wvalid            (axil_if.wvalid),
        .s_axi_wready            (axil_if.wready),
        .s_axi_bresp             (axil_if.bresp),
        .s_axi_bvalid            (axil_if.bvalid),
        .s_axi_bready            (axil_if.bready),
        .s_axi_araddr            (axil_if.araddr),
        .s_axi_arvalid           (axil_if.arvalid),
        .s_axi_arready           (axil_if.arready),
        .s_axi_rdata             (axil_if.rdata),
        .s_axi_rvalid            (axil_if.rvalid),
        .s_axi_rready            (axil_if.rready),
        .s_axi_rresp             (axil_if.rresp),
       
        // AXI-S Rx
        .s_axis_tdata            (axis_rx.tdata),
        .s_axis_tkeep            (axis_rx.tkeep),
        .s_axis_tvalid           (axis_rx.tvalid),
        .s_axis_tlast            (axis_rx.tlast),
        .s_axis_tready           (axis_rx.tready),
        
        // AXI-S Tx
        .m_axis_tdata            (axis_tx.tdata),
        .m_axis_tkeep            (axis_tx.tkeep),
        .m_axis_tvalid           (axis_tx.tvalid),
        .m_axis_tlast            (axis_tx.tlast),
        .m_axis_tready           (axis_tx.tready){{ ',' if props.hbm_axi_if_num > 0 }}

        {%- for hbm_if_idx,hbm_if_name in props.hbm_axi_ifs.items(): %}

        // HBM AXI {{ hbm_if_name }}
        .m_axi_hbm{{ hbm_if_name }}_awid        (axi_to_hbm[{{ hbm_if_idx }}].awid),     // output wire [{{ props.hbm_axi_if_id_wid - 1 }} : 0] m_axi_hbm{{ hbm_if_name }}_awid
        .m_axi_hbm{{ hbm_if_name }}_awaddr      (axi_to_hbm[{{ hbm_if_idx }}].awaddr),   // output wire [{{ props.hbm_axi_if_addr_wid - 1 }} : 0] m_axi_hbm{{ hbm_if_name }}_awaddr
        .m_axi_hbm{{ hbm_if_name }}_awlen       (axi_to_hbm[{{ hbm_if_idx }}].awlen),    // output wire [{{ props.hbm_axi_if_len_wid - 1 }} : 0] m_axi_hbm{{ hbm_if_name }}_awlen
        .m_axi_hbm{{ hbm_if_name }}_awsize      (axi_to_hbm[{{ hbm_if_idx }}].awsize),   // output wire [2 : 0] m_axi_hbm{{ hbm_if_name }}_awsize
        .m_axi_hbm{{ hbm_if_name }}_awburst     (axi_to_hbm[{{ hbm_if_idx }}].awburst),  // output wire [1 : 0] m_axi_hbm{{ hbm_if_name }}_awburst
        .m_axi_hbm{{ hbm_if_name }}_awlock      (axi_to_hbm[{{ hbm_if_idx }}].awlock),   // output wire [{{ props.hbm_axi_if_lock_wid -1 }} : 0] m_axi_hbm{{ hbm_if_name }}_awlock
        .m_axi_hbm{{ hbm_if_name }}_awcache     (axi_to_hbm[{{ hbm_if_idx }}].awcache),  // output wire [3 : 0] m_axi_hbm{{ hbm_if_name }}_awcache
        .m_axi_hbm{{ hbm_if_name }}_awprot      (axi_to_hbm[{{ hbm_if_idx }}].awprot),   // output wire [2 : 0] m_axi_hbm{{ hbm_if_name }}_awprot
        .m_axi_hbm{{ hbm_if_name }}_awqos       (axi_to_hbm[{{ hbm_if_idx }}].awqos),    // output wire [3 : 0] m_axi_hbm{{ hbm_if_name }}_awqos
        .m_axi_hbm{{ hbm_if_name }}_awregion    (axi_to_hbm[{{ hbm_if_idx }}].awregion), // output wire [3 : 0] m_axi_hbm{{ hbm_if_name }}_awregion
        .m_axi_hbm{{ hbm_if_name }}_awvalid     (axi_to_hbm[{{ hbm_if_idx }}].awvalid),  // output wire m_axi_hbm{{ hbm_if_name }}_awvalid
        .m_axi_hbm{{ hbm_if_name }}_awready     (axi_to_hbm[{{ hbm_if_idx }}].awready),  // input wire m_axi_hbm{{ hbm_if_name }}_awready
        .m_axi_hbm{{ hbm_if_name }}_wid         (axi_to_hbm[{{ hbm_if_idx }}].wid),      // output wire [{{ props.hbm_axi_if_id_wid - 1 }}: 0] m_axi_hbm{{ hbm_if_name }}_wid
        .m_axi_hbm{{ hbm_if_name }}_wdata       (axi_to_hbm[{{ hbm_if_idx }}].wdata),    // output wire [{{ props.hbm_axi_if_data_wid -1 }} : 0] m_axi_hbm{{ hbm_if_name }}_wdata
        .m_axi_hbm{{ hbm_if_name }}_wstrb       (axi_to_hbm[{{ hbm_if_idx }}].wstrb),    // output wire [{{ (props.hbm_axi_if_data_wid / 8 - 1) | int }} : 0] m_axi_hbm{{ hbm_if_name }}_wstrb
        .m_axi_hbm{{ hbm_if_name }}_wlast       (axi_to_hbm[{{ hbm_if_idx }}].wlast),    // output wire m_axi_hbm{{ hbm_if_name }}_wlast
        .m_axi_hbm{{ hbm_if_name }}_wvalid      (axi_to_hbm[{{ hbm_if_idx }}].wvalid),   // output wire m_axi_hbm{{ hbm_if_name }}_wvalid
        .m_axi_hbm{{ hbm_if_name }}_wready      (axi_to_hbm[{{ hbm_if_idx }}].wready),   // input wire m_axi_hbm{{ hbm_if_name }}_wready
        .m_axi_hbm{{ hbm_if_name }}_bid         (axi_to_hbm[{{ hbm_if_idx }}].bid),      // input wire [{{ props.hbm_axi_if_id_wid - 1 }} : 0] m_axi_hbm{{ hbm_if_name }}_bid
        .m_axi_hbm{{ hbm_if_name }}_bresp       (axi_to_hbm[{{ hbm_if_idx }}].bresp),    // input wire [1 : 0] m_axi_hbm{{ hbm_if_name }}_bresp
        .m_axi_hbm{{ hbm_if_name }}_bvalid      (axi_to_hbm[{{ hbm_if_idx }}].bvalid),   // input wire m_axi_hbm{{ hbm_if_name }}_bvalid
        .m_axi_hbm{{ hbm_if_name }}_bready      (axi_to_hbm[{{ hbm_if_idx }}].bready),   // output wire m_axi_hbm{{ hbm_if_name }}_bready
        .m_axi_hbm{{ hbm_if_name }}_arid        (axi_to_hbm[{{ hbm_if_idx }}].arid),     // output wire [{{ props.hbm_axi_if_id_wid - 1 }} : 0] m_axi_hbm{{ hbm_if_name }}_arid
        .m_axi_hbm{{ hbm_if_name }}_araddr      (axi_to_hbm[{{ hbm_if_idx }}].araddr),   // output wire [{{ props.hbm_axi_if_addr_wid - 1 }} : 0] m_axi_hbm{{ hbm_if_name }}_araddr
        .m_axi_hbm{{ hbm_if_name }}_arlen       (axi_to_hbm[{{ hbm_if_idx }}].arlen),    // output wire [{{ props.hbm_axi_if_len_wid - 1 }} : 0] m_axi_hbm{{ hbm_if_name }}_arlen
        .m_axi_hbm{{ hbm_if_name }}_arsize      (axi_to_hbm[{{ hbm_if_idx }}].arsize),   // output wire [2 : 0] m_axi_hbm{{ hbm_if_name }}_arsize
        .m_axi_hbm{{ hbm_if_name }}_arburst     (axi_to_hbm[{{ hbm_if_idx }}].arburst),  // output wire [1 : 0] m_axi_hbm{{ hbm_if_name }}_arburst
        .m_axi_hbm{{ hbm_if_name }}_arlock      (axi_to_hbm[{{ hbm_if_idx }}].arlock),   // output wire [{{ props.hbm_axi_if_lock_wid -1 }} : 0] m_axi_hbm{{ hbm_if_name }}_arlock
        .m_axi_hbm{{ hbm_if_name }}_arcache     (axi_to_hbm[{{ hbm_if_idx }}].arcache),  // output wire [3 : 0] m_axi_hbm{{ hbm_if_name }}_arcache
        .m_axi_hbm{{ hbm_if_name }}_arprot      (axi_to_hbm[{{ hbm_if_idx }}].arprot),   // output wire [2 : 0] m_axi_hbm{{ hbm_if_name }}_arprot
        .m_axi_hbm{{ hbm_if_name }}_arqos       (axi_to_hbm[{{ hbm_if_idx }}].arqos),    // output wire [3 : 0] m_axi_hbm{{ hbm_if_name }}_arqos
        .m_axi_hbm{{ hbm_if_name }}_arregion    (axi_to_hbm[{{ hbm_if_idx }}].arregion), // output wire [3 : 0] m_axi_hbm{{ hbm_if_name }}_arregion
        .m_axi_hbm{{ hbm_if_name }}_arvalid     (axi_to_hbm[{{ hbm_if_idx }}].arvalid),  // output wire m_axi_hbm{{ hbm_if_name }}_arvalid
        .m_axi_hbm{{ hbm_if_name }}_arready     (axi_to_hbm[{{ hbm_if_idx }}].arready),  // input wire m_axi_hbm{{ hbm_if_name }}_arready
        .m_axi_hbm{{ hbm_if_name }}_rid         (axi_to_hbm[{{ hbm_if_idx }}].rid),      // input wire [{{ props.hbm_axi_if_id_wid - 1 }} : 0] m_axi_hbm{{ hbm_if_name }}_rid
        .m_axi_hbm{{ hbm_if_name }}_rdata       (axi_to_hbm[{{ hbm_if_idx }}].rdata),    // input wire [{{ props.hbm_axi_if_data_wid -1 }} : 0] m_axi_hbm{{ hbm_if_name }}_rdata
        .m_axi_hbm{{ hbm_if_name }}_rresp       (axi_to_hbm[{{ hbm_if_idx }}].rresp),    // input wire [1 : 0] m_axi_hbm{{ hbm_if_name }}_rresp
        .m_axi_hbm{{ hbm_if_name }}_rlast       (axi_to_hbm[{{ hbm_if_idx }}].rlast),    // input wire m_axi_hbm{{ hbm_if_name }}_rlast
        .m_axi_hbm{{ hbm_if_name }}_rvalid      (axi_to_hbm[{{ hbm_if_idx }}].rvalid),   // input wire m_axi_hbm{{ hbm_if_name }}_rvalid
        .m_axi_hbm{{ hbm_if_name }}_rready      (axi_to_hbm[{{ hbm_if_idx }}].rready){{ ',' if not loop.last }}{{ ' ' if loop.last }}   // output wire m_axi_hbm00_rready
        {%- endfor %}
    );

    generate
        // Assign all other HBM AXI signals
        for (genvar i = 0; i < M_AXI_HBM_NUM_SLOTS; i++) begin : g__hbm_axi_if
            // Resynchronize reset
            logic aresetn;
            sync_reset #(
                .OUTPUT_ACTIVE_LOW(1)
            ) i_sync_reset (
                .rst_in(core_rstn),
                .clk_out(core_clk),
                .srst_out(aresetn)
            );
            // Drive clock/reset
            assign axi_to_hbm[i].aclk = core_clk;
            assign axi_to_hbm[i].aresetn = core_rstn;
            // Tie off user signals (unused)
            assign axi_to_hbm[i].awuser = '0;
            assign axi_to_hbm[i].wuser = '0;
            assign axi_to_hbm[i].aruser = '0;
        end : g__hbm_axi_if
        // Tie off unused interfaces
        for (genvar i = M_AXI_HBM_NUM_SLOTS; i < 16; i++) begin : g__hbm_axi_if_tieoff
            axi3_intf_controller_term i_axi3_intf_controller_term (.axi3_if ( axi_to_hbm[i] ));
        end : g__hbm_axi_if_tieoff
    endgenerate

endmodule : {{ props.name }}_wrapper

